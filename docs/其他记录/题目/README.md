## 本地存储技术
请描述一下 cookies sessionStorage和localstorage区别<br/>
cookies:酷king
localstorage：洛克死多里
sessionStorage：赛神死多里

1. 相同点：都存储在客户端
```javascript
不同点：1.存储大小
· cookie数据大小不能超过4k。
· sessionStorage和localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大。
```
2. 有效时间
```javascript
· localStorage    存储持久数据，浏览器关闭后数据不丢失除非主动删除数据；
· sessionStorage  数据在当前浏览器窗口关闭后自动删除。
· cookie          设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭
```
3. 数据与服务器之间的交互方式
```javascript
· cookie的数据会自动的传递到服务器，服务器端也可以写cookie到客户端
· sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存。
```

## 数组去重
数组去重:<br/>
编写一个方法去掉数组里面重复的内容<br/>
```javascript
var arr = ['abc','abcd','sss','2','d','t','2','ss','f','22','d'];
//定义一个新的数组
var s = [];
//遍历数组
for(var i = 0;i<arr.length;i++){
    if(s.indexOf(arr[i]) == -1){  //判断在s数组中是否存在，不存在则push到s数组中 此处的-1代表的是false
        s.push(arr[i]);
    }
}
console.log(s);
//输出结果：["abc", "abcd", "sss", "2", "d", "t", "ss", "f", "22"]
```
<br/><br/><br/><br/>

## http状态码
常见的HTTP状态码
```javascript
2开头 （请求成功）表示成功处理了请求的状态代码。
200   （成功）  服务器已成功处理了请求。 通常，这表示服务器提供了请求的网页。 
201   （已创建）  请求成功并且服务器创建了新的资源。 
202   （已接受）  服务器已接受请求，但尚未处理。 
203   （非授权信息）  服务器已成功处理了请求，但返回的信息可能来自另一来源。 
204   （无内容）  服务器成功处理了请求，但没有返回任何内容。 
205   （重置内容） 服务器成功处理了请求，但没有返回任何内容。
206   （部分内容）  服务器成功处理了部分 GET 请求。
3开头 （请求被重定向）表示要完成请求，需要进一步操作。 通常，这些状态代码用来重定向。
300   （多种选择）  针对请求，服务器可执行多种操作。 服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择。 
301   （永久移动）  请求的网页已永久移动到新位置。 服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。
302   （临时移动）  服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。
303   （查看其他位置） 请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码。
304   （未修改） 自从上次请求后，请求的网页未修改过。 服务器返回此响应时，不会返回网页内容。 
305   （使用代理） 请求者只能使用代理访问请求的网页。 如果服务器返回此响应，还表示请求者应使用代理。 
307   （临时重定向）  服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。
4开头 （请求错误）这些状态代码表示请求可能出错，妨碍了服务器的处理。
400   （错误请求） 服务器不理解请求的语法。 
401   （未授权） 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。 
403   （禁止） 服务器拒绝请求。
404   （未找到） 服务器找不到请求的网页。
405   （方法禁用） 禁用请求中指定的方法。 
406   （不接受） 无法使用请求的内容特性响应请求的网页。 
407   （需要代理授权） 此状态代码与 401（未授权）类似，但指定请求者应当授权使用代理。
408   （请求超时）  服务器等候请求时发生超时。 
409   （冲突）  服务器在完成请求时发生冲突。 服务器必须在响应中包含有关冲突的信息。 
410   （已删除）  如果请求的资源已永久删除，服务器就会返回此响应。 
411   （需要有效长度） 服务器不接受不含有效内容长度标头字段的请求。 
412   （未满足前提条件） 服务器未满足请求者在请求中设置的其中一个前提条件。 
413   （请求实体过大） 服务器无法处理请求，因为请求实体过大，超出服务器的处理能力。 
414   （请求的 URI 过长） 请求的 URI（通常为网址）过长，服务器无法处理。 
415   （不支持的媒体类型） 请求的格式不受请求页面的支持。 
416   （请求范围不符合要求） 如果页面无法提供请求的范围，则服务器会返回此状态代码。 
417   （未满足期望值） 服务器未满足"期望"请求标头字段的要求。
5开头（服务器错误）这些状态代码表示服务器在尝试处理请求时发生内部错误。 这些错误可能是服务器本身的错误，而不是请求出错。
500   （服务器内部错误）  服务器遇到错误，无法完成请求。 
501   （尚未实施） 服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码。 
502   （错误网关） 服务器作为网关或代理，从上游服务器收到无效响应。 
503   （服务不可用） 服务器目前无法使用（由于超载或停机维护）。 通常，这只是暂时状态。 
504   （网关超时）  服务器作为网关或代理，但是没有及时从上游服务器收到请求。 
505   （HTTP 版本不受支持） 服务器不支持请求中所用的 HTTP 协议版本。

```


## HTTP和HTTPS协议的区别
**HTTP和HTTPS协议的区别**

区别：

1. https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。
2. http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。
3. http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。
4. http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。

## get和post请求的区别
get和post都是http请求的方式<br/>
 **get请求**
1. GET 请求的表现形式，即请求的数据会附在 URL 之后（放在请求行中），以 ? 分割 URL 和传输数据，多个参数用 & 连接。
2. 除此之外，根据 HTTP 规范，GET 用于信息获取，而且应该是安全和幂等的 。
>安全性指的是非修改信息，即该操作用于获取信息而非修改信息。换句话说，GET请求一般不应产生副作用，也就是说，它仅仅是获取资源信息，就像数据库查询一样，不会修改，增加数据，不会影响资源的状态。

>幂等性 (Idempotence) 则指的是无论调用这个URL 多少次，都不会有不同的结果的 HTTP 方法。而在实际过程中，这个规定没有那么严格。例如在一个新闻应用中，新闻站点的头版不断更新，虽然第二次请求会返回不同的一批新闻，该操作仍然被认为是安全的和幂等的，因为它总是返回当前的新闻。
3. GET 是会被浏览器主动缓存的，如果下一次传输的数据相同，那么就会返回缓存中的内容，以求更快地展示数据。
4. GET 方法的 URL 一般都具有长度限制，**但是需要注意的是 HTTP 协议中并未规定 GET 请求的长度。这个长度限制主要是由浏览器和 Web 服务器所决定的，并且各个浏览器对长度的限制也各不相同。**
5. GET 方法只产生一个 TCP 数据包，浏览器会把请求头和请求数据一并发送出去，服务器响应 200 ok(返回数据)。

 **post请求方式**
1. 根据 HTTP 规范，POST 表示可能修改变服务器上的资源的请求。例如我们在刷知乎的时候对某篇文章进行点赞，就是提交的 POST 请求，因为它改变了服务器中的数据（该篇文章的点赞数）。

2. POST 方法因为有可能修改服务器上的资源，所以它是不符合安全和幂等性的。

3. 从前面关于 POST 的请求报文也可以看出，POST 是将请求信息放置在请求数据中的，这也是 POST 和 GET 的一点不那么重要的区别。有一些博客的说法是 **GET 请求的请求信息是放置在 URL 的而 POST 是放置在请求数据中的**所以 POST 比 GET 更安全。

4. 因为 POST 方法的请求信息是放置在请求数据中的，所以它的请求信息是**没有长度限制**的。

5. POST 方法会产生两个 TCP 数据包，浏览器会先将请求头发送给服务器，待服务器响应100 continue，浏览器再发送请求数据，服务器响应200 ok(返回数据)。这么看起来 **GET 请求的传输会比 POST 快上一些**（因为GET 方法只发送一个 TCP 数据包），但是实际上在网络良好的情况下它们的传输速度基本相同。


### 小结
get和post实际上都是Tcp链接，并无太大区别，但是由于http的规定以及浏览器/服务器的限制，导致他们在应用过程中可能会有所不同<br/>
单纯获取资源的请求就规定为get<br/>
修改服务器资源的请求就规定为post<br/>

```javascript
GET在浏览器回退时是无害的，而POST会再次提交请求。
GET产生的URL地址可以被Bookmark，而POST不可以。
GET请求会被浏览器主动cache，而POST不会，除非手动设置。
GET请求只能进行url编码，而POST支持多种编码方式。
GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。
GET请求在URL中传送的参数是有长度限制的，而POST么有。
对参数的数据类型，GET只接受ASCII字符，而POST没有限制。
GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。
GET参数通过URL传递，POST放在Request body中。
```


## 什么是mvvm？
```javascript

它是将“数据模型数据双向绑定”的思想作为核心，因此在View和Model之间没有联系，
通过ViewModel进行交互，而且Model和ViewModel之间的交互是双向的，
因此视图的数据的变化会同时修改数据源，而数据源数据的变化也会立即反应view。
微信小程序前端使用mvvm。

```


## 递归
**认识递归**

满足以下三个特点就是递归：
1. 函数自己调用自己
2. 一般情况有参数
3. 一般情况下有return

递归方法:
  1. 首先去找临界值，即无需计算，获得的值。
  2. 找这一次和上一次的关系
  3. 假设当前函数已经可以使用，调用自身计算上一次

弊端：短时间开启大量的内存，一次性再释放内存，会卡顿或者死机<br/>
在没有算出那个临界值之前，会开启所有的内存计算每一个公式，算出来之后才会依次释放内存



```javascript
// 计算1~n的和？
function sum(n){
  var res = 0;
  for(var i = 1; i <= n; i++){
    res += i;
  }
  return res;
}
alert(sum(100));



// 递归方法计算1~n的和？
function sum(n){
  if(n == 1){
    return 1;
  }
  return sum(n - 1) + n;
}
alert(sum(100));
```


## 闭包
什么是闭包，如何使用它，为什么要使用它？

满足以下特点的就是闭包：<br/>
1. 函数嵌套函数
2. 内部函数使用外部函数的形参和变量
3. 被引用的形参和变量就不会被(垃圾回收机制所回收)

闭包的作用：<br/>
1. 可以是变量常驻在内存当中
2. 可以读取函数内部的变量
3. 避免全局变量污染(开发中如果声明的是全局变量的话，多人协作难免会出现重复的变量)
4. 可以声明私有成员

闭包的缺点：
1. 闭包使函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包否则会造成网页的性能问题


```javascript
var a = 2; //声明全局变量，会造成变量我污染
function show(){
    a++;
    alert(a)
}
alert(a); //2
show(); //3
shwo(); //4



function show(){
    var a = 2;
    a++;
    alert(a)
}
show();//3
show();//3
alert(a);//报错(回收机制)



function aaa(){
    var a = 2;
    function bbb(){
        a++;
        alert(a);
    }
    return bbb;
}
var ccc = aaa();
ccc();
ccc();
alert(a)//局部变量访问不到
```

立即执行函数：
```javascript
()()//两个括号，先声明这个函数，再执行
(function show(){
    alert('hello world')
})()


var ccc = (function(){
    var a = 2;
    return function(){
        a++;
        alert(a)
    } 
})()

ccc();//3
ccc();//4
alert(a)//报错
```

## 从输入url到显示页面，都经历了什么？
```javascript
1、首先，在浏览器地址栏中输入url。
2、浏览器先查看浏览器缓存-系统缓存-路由器缓存，如果缓存中有，会直接在屏幕中显示页面内容。若没有，则跳到第三步操作。
3、在发送http请求前，需要域名解析(DNS解析)(DNS（域名系统，Domain Name System）是互联网的一项核心服务，它作为可以将域名和IP地址相互映射的一个分布式数据库，能够使人更方便的访问互联网，而不用去记住IP地址。)，解析获取相应的IP地址。
4、浏览器向服务器发起tcp连接，与浏览器建立tcp三次握手。（TCP即传输控制协议。TCP连接是互联网连接协议集的一种。）
5、握手成功后，浏览器向服务器发送http请求，请求数据包。
6、服务器处理收到的请求，将数据返回至浏览器。
7、浏览器收到HTTP响应。
8、读取页面内容，浏览器渲染，解析html源码。
9、生成Dom树、解析css样式、js交互。
10、客户端和服务器交互。
11、ajax查询。

```

## 选择题
```javascript
w3c 制定的 javascript 标准事件模型，以下正确的顺序以及描述是
A.事件捕获>事件冒泡
B.事件捕获->事件处理->事件冒泡
C.事件冒泡->事件处理
D.事件冒泡->事件处理->事件捕获
E.事件处理->事件捕获->事件冒泡
答案 b
```

## v-if和v-show的区别
请问 v-if 和 v-show 有什么区别？

a.实现方式： v-if是根据后面数据的真假值判断直接从Dom树上删除或重建元素节点。  v-show只是在修改元素的css样式，也就是display的属性值，元素始终在Dom树上。

b.编译过程：v-if切换有一个局部编译/卸载的过程，切换过程中合适地销毁和重建内部的事件监听和子组件；  v-show只是简单的基于css切换；

c.编译条件：v-if是惰性的，如果初始条件为假，则什么也不做；只有在条件第一次变为真时才开始局部编译； v-show是在任何条件下（首次条件是否为真）都被编译，然后被缓存，而且DOM元素始终被保留；

d.性能消耗：v-if有更高的切换消耗，不适合做频繁的切换；  v-show有更高的初始渲染消耗，适合做频繁的额切换；


## vue双向数据绑定
**vue双向数据绑定**<br/>
Vue是采用数据劫持结合发布/订阅模式的方式<br/>
通过Object.defineProperty()来劫持各个属性的setter，getter<br/>
在数据变动时发布消息给订阅者，触发相应的监听回调。<br/>

Object.defineProperty()<br/>
读法：o波j.d烦 泼播踢<br/>

1. 实现一个监听器Observer，用来劫持并监听所有属性，如果有变动的，就通知订阅者。
2. 实现一个订阅者Watcher，可以收到属性的变化通知并执行相应的函数，从而更新视图。
3. 实现一个解析器Compile，可以扫描和解析每个节点的相关指令，并根据初始化模板数据以及初始化相应的订阅器。

![text](./img/shuangxiang.jpg)


## vue中 key 值的作用
使用key来给每个节点做一个唯一标识<br/>
key的作用主要是为了**高效的更新虚拟DOM**。另外vue中在使用相同标签名元素的过渡切换时，也会使用到key属性，其目的也是为了让vue可以区分它们，<br/>
否则vue只会替换其内部属性而不会触发过渡效果。<br/>


## let const的解释

var的设计可以看成JavaScript语言设计上的错误，这种错误多半不能修复和移除<br/>
我们可以将let看成更完美的var<br/>
JS中使用var来声明一个变量时, 变量的作用域主要是和函数的定义有关<br/>
es5只有function有作用域，ES5中的var是没有块级作用域的(if/for)<br/>
针对于其他块定义来说是没有作用域的，比如if/for等，这在我们开发中往往会引起一些问题<br/>
ES6中,加入了let, let它是有if和for的块级作用域 <br/>

let 关键字是用来声明变量   更过分，只要遇到大括号就形成作用域<br/>
【注】let关键字声明的变量，所在作用域叫做块级作用域。<br/>

const 声明变量，变量值只能在声明的时候确定，后续是没有办法修改的。<br/>
【注】const声明常量(变量没有办法改);<br/>

```javascript
    // 一旦给const修饰的标识符被赋值之后, 不能修改
    // 在使用const定义标识符,必须进行赋值
    const name = 'why';
    name = 'abc'
    // const的变量不能被修改，所以还是why
    console.log(name)  

    

    // 常量的含义是指向的对象不能修改, 但是可以改变对象内部的属性.
    const obj = {
        name: 'taotao',
    }
    console.log(obj.name);
    // obj = {}  这样改会报错
    obj.name = 'jiapeng'; //这样改不会报错
    console.log(obj.name);
```

## 箭头函数
```javascript
    箭头函数:新潮的函数写法
    [注]作用：适当的省略函数中的 function和return关键字
    不利：代码可读性减弱，阅读时间花费多

    注：箭头函数需注意部分
    1，箭头函数不能用new

    2，箭头函数如果返回值是一个对象，一定要加()
    普通：
    const show = () => {
    }
    返回值为对象：
    const show = () => ({
    })

    // 3,箭头函数中的this指向的是上一层函数的主人
    let person = {
        username:'钢铁侠',
        // show: function(){
        //     alert(person.username)
        //     alert(this.username)
        //     //此处两者alert指向同一个
        // }

        show: () => {
            alert(person.username)
            alert(this.username)
            //此处this指向window
        }
    }
```

例如：
```javascript
    //1，无参数，无返回值
    function show(){
        alert('hello word');
    }

    const show = () => {
        alert('hello word');
    }

    //2,有一个参数，无返回值
    function xxx(num){
        alert(num);
    }

    const xxx = num => {
        alert(num);
    }

    //3,有一个参数有返回值
    var x = 5
    function add(x){
        return x+10;
        
    }
    alert(add(x))

    const add = x =>{
        return x + 10;
    } 
    alert(add(x))

    //4,多个参数，有返回值
    const x = 10
    const y = 20
    function show (x,y){
        alert(x + y);
    }

    const show = (x,y) => {
        alert(x+y);
    }
```


## 绝对定位和相对定位的区别
一：绝对定位  position：absolute (泼赛神：啊波死路)<br/>
绝对定位是相对于元素最近的已定位的祖先元素（即是设置了绝对定位或者相对定位的祖先元素）。如果元素没有已定位的祖先元素，那么它的位置则是相对于最初的包含块（body）。<br/>
绝对定位本身与文档流无关，因此不占空间，普通文档流中的元素的布局就当绝对定位的元素不存时一样，所以 它们可以覆盖页面上其他的元素，且可以通过z-index属性来控制这些层的对方顺序。<br/>
**脱离文档流**

二：相对定位  position：relative(威了踢死)<br/>
相对定位是相对于元素在文档中的**初始位置**——首先它出现在它所在的位置上（即不设置position时的位置，然后通过设置垂直或水平位置，让这个元素“相对于”它的原始起点进行移动；注意，在使用相对定位时，无论是否进行移动，**元素仍然占据原来的空间**。因此，移动元素会导致它覆盖其它框。<br/>
**不脱离文档流**<br/>

## 水平垂直居中方法

Flex 方案<br/>
Grid 方案<br/>
absolute(啊波死路) + transform(穿死货)<br/>
absolute + calc<br/>
absolute + 负 margin<br/>
absolute + margin: auto<br/>
writing-mode<br/>


